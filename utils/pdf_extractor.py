#!/usr/bin/env python3
"""
M√≥dulo de extra√ß√£o de PDFs usando PyMuPDF
Implementa extra√ß√£o real de preview da primeira p√°gina
"""

import logging
import io
from typing import Optional, Tuple
from PIL import Image
import fitz  # PyMuPDF

logger = logging.getLogger(__name__)

def extract_pdf_preview(pdf_bytes: bytes, page_index: int = 0, dpi: int = 150) -> Optional[bytes]:
    """
    Extrai preview real da primeira p√°gina do PDF
    
    Args:
        pdf_bytes: Conte√∫do do PDF em bytes
        page_index: √çndice da p√°gina (0 = primeira)
        dpi: Resolu√ß√£o da imagem (padr√£o 150)
    
    Returns:
        Bytes da imagem PNG ou None se falhar
    """
    try:
        logger.info(f"üîç Iniciando extra√ß√£o de preview - PDF: {len(pdf_bytes)} bytes, p√°gina: {page_index}, DPI: {dpi}")
        
        # Abrir PDF com PyMuPDF
        pdf_doc = fitz.open(stream=pdf_bytes, filetype="pdf")
        
        if len(pdf_doc) == 0:
            logger.error("‚ùå PDF vazio - nenhuma p√°gina encontrada")
            return None
        
        if page_index >= len(pdf_doc):
            logger.warning(f"‚ö†Ô∏è P√°gina {page_index} n√£o existe. PDF tem {len(pdf_doc)} p√°ginas. Usando p√°gina 0.")
            page_index = 0
        
        # Obter p√°gina
        page = pdf_doc[page_index]
        logger.info(f"üìÑ P√°gina {page_index} carregada - Dimens√µes: {page.rect}")
        
        # Calcular matriz de transforma√ß√£o para DPI
        zoom = dpi / 72.0  # 72 DPI √© padr√£o
        matrix = fitz.Matrix(zoom, zoom)
        
        # Renderizar p√°gina como imagem
        logger.info(f"üé® Renderizando p√°gina com zoom {zoom:.2f}x (DPI: {dpi})")
        pix = page.get_pixmap(matrix=matrix, alpha=False)
        
        # Converter para PNG
        img_bytes = pix.tobytes("png")
        
        # Fechar documento
        pdf_doc.close()
        
        logger.info(f"‚úÖ Preview extra√≠do com sucesso - {len(img_bytes)} bytes PNG")
        return img_bytes
        
    except Exception as e:
        logger.error(f"‚ùå Erro na extra√ß√£o de preview: {e}")
        return None

def get_pdf_info(pdf_bytes: bytes) -> dict:
    """
    Obt√©m informa√ß√µes b√°sicas do PDF
    
    Args:
        pdf_bytes: Conte√∫do do PDF em bytes
    
    Returns:
        Dicion√°rio com informa√ß√µes do PDF
    """
    try:
        pdf_doc = fitz.open(stream=pdf_bytes, filetype="pdf")
        
        info = {
            'page_count': len(pdf_doc),
            'metadata': pdf_doc.metadata,
            'is_encrypted': pdf_doc.needs_pass,
            'is_pdf': pdf_doc.is_pdf,
            'file_size': len(pdf_bytes)
        }
        
        # Obter dimens√µes da primeira p√°gina
        if len(pdf_doc) > 0:
            page = pdf_doc[0]
            rect = page.rect
            info['first_page_size'] = {
                'width': rect.width,
                'height': rect.height,
                'width_mm': rect.width * 25.4 / 72,
                'height_mm': rect.height * 25.4 / 72
            }
        
        pdf_doc.close()
        logger.info(f"üìä Informa√ß√µes PDF obtidas: {info['page_count']} p√°ginas")
        return info
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao obter informa√ß√µes do PDF: {e}")
        return {'error': str(e)}

def extract_text_from_pdf(pdf_bytes: bytes, max_pages: int = 1) -> str:
    """
    Extrai texto do PDF com l√≥gica inteligente de OCR
    
    Uses OCR fallback if:
    - Direct text is too short (< 50 characters)
    - Contains "assinado" (indicates scanned/signed document)
    
    Args:
        pdf_bytes: Conte√∫do do PDF em bytes
        max_pages: M√°ximo de p√°ginas para extrair texto
    
    Returns:
        Texto extra√≠do
    """
    try:
        pdf_doc = fitz.open(stream=pdf_bytes, filetype="pdf")
        text_parts = []
        
        pages_to_extract = min(len(pdf_doc), max_pages)
        
        for page_num in range(pages_to_extract):
            page = pdf_doc[page_num]
            
            # 1. Extra√ß√£o de texto direto
            direct_text = page.get_text("text")
            logger.info(f"üìÑ P√°gina {page_num + 1}: texto direto com {len(direct_text)} caracteres")
            
            # 2. L√≥gica de decis√£o para OCR
            is_signed = "assinado" in direct_text.lower()
            is_short = len(direct_text.strip()) < 50
            needs_ocr = is_short or is_signed
            
            if needs_ocr:
                reason = "Palavra 'assinado' detectada" if is_signed else "Texto insuficiente"
                logger.info(f"üîç {reason} na p√°gina {page_num + 1}. Aplicando OCR...")
                
                try:
                    # Renderizar p√°gina como imagem para OCR
                    pix = page.get_pixmap(dpi=400)  # Alta resolu√ß√£o para melhor OCR
                    img_bytes = pix.tobytes("png")
                    
                    # Usar AWS Textract para OCR (se dispon√≠vel)
                    ocr_text = _extract_text_with_textract(img_bytes)
                    
                    if ocr_text and len(ocr_text) > len(direct_text):
                        page_text = ocr_text
                        logger.info(f"‚úÖ OCR produziu mais texto ({len(ocr_text)} chars vs {len(direct_text)} chars)")
                    else:
                        page_text = direct_text
                        logger.info(f"‚ö†Ô∏è Usando texto direto (OCR: {len(ocr_text or '')} chars)")
                        
                except Exception as ocr_error:
                    logger.error(f"‚ùå Erro no OCR da p√°gina {page_num + 1}: {ocr_error}")
                    page_text = direct_text
            else:
                page_text = direct_text
                logger.info(f"üìù Usando texto direto da p√°gina {page_num + 1}")
            
            if page_text.strip():
                text_parts.append(f"=== P√ÅGINA {page_num + 1} ===\n{page_text}\n")
        
        pdf_doc.close()
        
        full_text = "\n".join(text_parts)
        logger.info(f"üìù Texto final extra√≠do de {pages_to_extract} p√°gina(s) - {len(full_text)} caracteres")
        return full_text
        
    except Exception as e:
        logger.error(f"‚ùå Erro na extra√ß√£o de texto: {e}")
        return ""


def _extract_text_with_textract(image_bytes: bytes) -> str:
    """
    Extrai texto de imagem usando AWS Textract
    
    Args:
        image_bytes: Bytes da imagem PNG
    
    Returns:
        Texto extra√≠do via OCR
    """
    try:
        import boto3
        from botocore.exceptions import ClientError
        
        textract = boto3.client('textract')
        
        # Verificar tamanho (Textract tem limite de 5MB)
        if len(image_bytes) > 5 * 1024 * 1024:
            logger.warning(f"‚ö†Ô∏è Imagem muito grande para Textract: {len(image_bytes)} bytes")
            return ""
        
        logger.info(f"ü§ñ Usando AWS Textract para OCR ({len(image_bytes)} bytes)")
        
        response = textract.detect_document_text(
            Document={'Bytes': image_bytes}
        )
        
        # Extrair texto das linhas detectadas
        text_lines = []
        for block in response.get('Blocks', []):
            if block['BlockType'] == 'LINE':
                text_lines.append(block['Text'])
        
        ocr_text = '\n'.join(text_lines)
        logger.info(f"ü§ñ Textract extraiu {len(ocr_text)} caracteres")
        
        return ocr_text
        
    except ClientError as e:
        logger.error(f"‚ùå Erro do Textract: {e}")
        return ""
    except Exception as e:
        logger.error(f"‚ùå Erro geral no OCR: {e}")
        return ""

def validate_pdf(pdf_bytes: bytes) -> Tuple[bool, str]:
    """
    Valida se o arquivo √© um PDF v√°lido
    
    Args:
        pdf_bytes: Conte√∫do do arquivo em bytes
    
    Returns:
        Tupla (√©_v√°lido, mensagem)
    """
    try:
        if len(pdf_bytes) < 100:
            return False, "Arquivo muito pequeno para ser um PDF"
        
        # Verificar header PDF
        if not pdf_bytes.startswith(b'%PDF-'):
            return False, "Arquivo n√£o possui header PDF v√°lido"
        
        # Tentar abrir com PyMuPDF
        pdf_doc = fitz.open(stream=pdf_bytes, filetype="pdf")
        
        if len(pdf_doc) == 0:
            pdf_doc.close()
            return False, "PDF n√£o cont√©m p√°ginas"
        
        if pdf_doc.needs_pass:
            pdf_doc.close()
            return False, "PDF protegido por senha"
        
        pdf_doc.close()
        return True, "PDF v√°lido"
        
    except Exception as e:
        return False, f"Erro ao validar PDF: {e}"

# Fun√ß√£o de teste para desenvolvimento
def test_extraction():
    """Fun√ß√£o de teste para verificar se a extra√ß√£o funciona"""
    try:
        # Criar um PDF simples para teste
        import fitz
        
        # Criar documento de teste
        doc = fitz.open()
        page = doc.new_page(width=595, height=842)  # A4
        
        # Adicionar texto
        text = "TESTE DE EXTRA√á√ÉO\nExtractBrowser EC2\nPDF gerado para teste"
        page.insert_text((50, 50), text, fontsize=12)
        
        # Salvar como bytes
        pdf_bytes = doc.tobytes()
        doc.close()
        
        logger.info("üß™ Testando extra√ß√£o com PDF de teste...")
        
        # Testar valida√ß√£o
        is_valid, msg = validate_pdf(pdf_bytes)
        logger.info(f"Valida√ß√£o: {is_valid} - {msg}")
        
        # Testar extra√ß√£o de info
        info = get_pdf_info(pdf_bytes)
        logger.info(f"Info: {info}")
        
        # Testar extra√ß√£o de preview
        preview_bytes = extract_pdf_preview(pdf_bytes)
        if preview_bytes:
            logger.info(f"‚úÖ Preview extra√≠do: {len(preview_bytes)} bytes")
            return True
        else:
            logger.error("‚ùå Falha na extra√ß√£o de preview")
            return False
            
    except Exception as e:
        logger.error(f"‚ùå Erro no teste: {e}")
        return False

if __name__ == "__main__":
    # Configurar logging para teste
    logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')
    
    print("üß™ Testando m√≥dulo de extra√ß√£o PDF...")
    success = test_extraction()
    print(f"Resultado: {'‚úÖ Sucesso' if success else '‚ùå Falha'}")
